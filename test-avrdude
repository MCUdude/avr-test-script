#!/usr/bin/env bash

# published under GNU General Public License, version 3 (GPL-3.0)
# authors Hans Eirik Bull and Stefan Rueger, 2024

progname=$(basename "$0")

avrdude_conf=''                 # Configuration for every run, eg, '-C path_to_avrdude_conf'
delay=4                         # Some programmers need a delay between AVRDUDE calls
avrdude_bin=avrdude             # Executable
list_only=0                     # Normal run
declare -a pgm_and_target=()    # Array with test option strings, eg, "-c dryrun -p m328p"
skip_eeprom=0                   # Do not skip EEPROM tests for bootloaders by default
verbose=0                       # Do not show AVRDUDE errors and warnings by default

Usage() {
cat <<END
Syntax: $progname {<opts>}
Function: test AVRDUDE for certain programmer and part combinations
Options:
    -c <configuration spec>     additional configuration options used for all runs
    -d <sec>                    delay between test commands (default $delay seconds)
    -e <avrdude path>           set path of AVRDUDE executable (default $avrdude_bin)
    -l                          list test commands but do not execute them
    -p <programmer/part specs>  can be used multiple times, overrides default tests
    -s                          skip EEPROM tests for bootloaders
    -v                          verbose: show AVRDUDE error and warning messages
    -? or -h                    show this help text
Example:
    \$ $progname -d 0 -p "-c dryrun -p t13" -p "-c dryrun -p m4809"
END
}

while getopts ":\?hc:d:e:lp:sv" opt; do
  case ${opt} in
    c) avrdude_conf="$OPTARG"
        ;;
    d) delay="$OPTARG"
        ;;
    e) avrdude_bin="$OPTARG"
        ;;
    l) list_only=1
        ;;
    p) pgm_and_target+=("$OPTARG")
        ;;
    s) skip_eeprom=1
        ;;
    v) verbose=1
        ;;
    --) shift;
        break
        ;;
   [h?])
       Usage; exit 0
        ;;
   \?) echo "Invalid option: -$OPTARG" 1>&2
       Usage; exit 1
        ;;
   : ) echo "Invalid option: -$OPTARG requires an argument" 1>&2
       Usage; exit 1
       ;;
  esac
done
shift $((OPTIND -1))

if [[ ${#pgm_and_target[@]} -eq 0 ]]; then
  # Default tests in absence of -p
  pgm_and_target+=(
    "-cdryrun -pm328p"
    "-cdryrun -px64a1"
    "-cpkobn_updi -B1 -patmega3208"
    "-cpkobn_updi -B1 -patmega3209"
    "-cpkobn_updi -B1 -patmega4808"
    "-cjtag2updi -patmega4809 -Pusb:2341:0058 -r"
    "-cpkobn_updi -B1 -pattiny3217"
    "-cpkobn_updi -B1 -pavr128da48"
    "-cpkobn_updi -B1 -pavr128db48"
    "-cpkobn_updi -B1 -pavr64dd32"
    "-cpkobn_updi -B1 -pavr64ea48"
    "-cpkobn_updi -B1 -pavr16eb32"
    "-cxplainedmini_isp -patmega328pb"
    "-cxplainedmini_updi -pattiny1616"
    "-cxplainedmini_updi -pattiny3217"
    "-cxplainedpro_updi -B1 -pattiny817"
    "-cxplainedpro_pdi -B0.5 -patxmega128a1u"
    "-cxplainedpro -B4MHz -patmega256rfr2"
  )
fi

arraylength=${#pgm_and_target[@]}
echo -n "Testing $avrdude_bin"
$avrdude_bin -v 2>&1 | grep Version | cut -f2- -d: | sed s/Version/version/

tmp=/dev/shm                    # Temporary RAM directory
[ ! -d $tmp ] && tmp=/tmp       # Fall back to /tmp if it does not exist
status=$(mktemp "$tmp/$progname.status.XXXXXX")
logfile=$(mktemp "$tmp/$progname.log.XXXXXX")
outfile=$(mktemp "$tmp/$progname.out.XXXXXX")
trap "rm -f $status $logfile $outfile" EXIT

TIMEFORMAT=%R                   # time built-in only returns elapsed wall-clock time
elapsed=0                       # Global variable holding time of last execute command in seconds
command=(sleep 0.1)             # Array with AVRDUDE command

# Execute args as command, set $elapsed and return exit value of command; don't call in a subshell
execute () {
  if [[ $list_only -eq 1 ]]; then
    echo "\$ ${command[@]}" | tr -s " "
    return 0;
  fi
  sleep "$delay"
  # These shenanigans keep stdout, stderr and the exit code of the command
  { read elapsed < <({ time { eval "$@"; echo $? >"$status"; } 2>&4 4>&-; } 4>&2 2>&1 >&3 3>&-); } 3>&1
  return $(cat "$status")
}

# Evaluate condition, print execution time and success or failure
result () {
  local ret=0;

  eval "$@" && ret=0 || ret=1
  if [[ $list_only -eq 0 ]]; then
    if [[ $ret -eq 0 ]]; then
      echo ✅ "$(printf '%7.3f s' $elapsed): $specify"
    else
      echo ❌ "$(printf '%7.3f s' $elapsed): $specify (failed command below)"
      echo "\$ ${command[@]}" | tr -s " "
      FAIL=true
    fi
    [[ $verbose -eq 1 ]] && { touch $logfile $outfile; cat $logfile $outfile; }
  else
    touch $outfile; cat $outfile
  fi
  rm -f $logfile $outfile; elapsed=-999; specify="unknown"; command=(sleep 0.1)
  return $ret
}

for (( p=0; p<$arraylength; p++ )); do
  if [[ $list_only -eq 1 ]]; then
    [[ p -ne 0 ]] && echo
    echo "# ${pgm_and_target[$p]}"
    key=''
  else
    echo "Prepare \"${pgm_and_target[$p]}\" and press 'enter' or 'space' to continue. Press any other key to skip"
    read -n1 -s -r -p $'' key
    sleep 0.25
  fi

  if [ "$key" == '' ]; then
    FAIL=false
    avrdude=($avrdude_bin $avrdude_conf -qq ${pgm_and_target[$p]} -l $logfile)

    # Get flash and EEPROM size in bytes and make sure the numbers are in dec form
    FLASH_SIZE=$(${avrdude[@]} -cdryrun -T 'part -m' 2>/dev/null | grep flash | awk '{print $2}')
    EE_SIZE=$(${avrdude[@]} -cdryrun -T 'part -m' 2>/dev/null | grep eeprom | awk '{print $2}')
  
    if [[ -z "$FLASH_SIZE" ]]; then
      echo "No flash? Skipping ${pgm_and_target[$p]} test"
      continue
    fi

    # Memories that may or may not be present
    USERSIG_SIZE=$(${avrdude[@]} -cdryrun -T 'part -m' 2>/dev/null | grep usersig | awk '{print $2}') # R/W

    # Is the to be tested programmer for a bootloader?
    is_bootloader=0
    # Isolate programmer (assumes either -c prog or -cprog but not sth more tricky such as -qc prog)
    programmer=$(echo ${pgm_and_target[$p]} | sed 's/  *\([^-]\)/\1/g' | tr \  \\n | grep ^-c)
    if [ -n "$programmer" ]; then
      ($avrdude_bin $avrdude_conf "$programmer"/At 2>/dev/null | grep -q prog_modes.PM_SPM) && is_bootloader=1
    fi

    # Should EEPROM test be carried out?
    check_eeprom=1
    [[ -z "$EE_SIZE" ]] && check_eeprom=0
    [[ $is_bootloader -eq 1 && $skip_eeprom -eq 1 ]] && check_eeprom=0

    #####
    # Dryrun tests @@@ Todo: add more tests...
    #
    if [[ "$programmer" == -cdryrun ]]; then
      # Raw test
      specify="cola-vending-machine.raw flash -T/-U write/verify"
      command=(${avrdude[@]}
        -T '"erase flash; write flash -512 0xc0cac01a 0xcafe \"secret Coca .bin recipe\""'
        -U flash:w:test_files/cola-vending-machine.raw
        -T '"write flash -1024 \"Hello World\""')
      execute "${command[@]}" > $outfile
      result [[ ! -s $outfile '&&' ! -s $logfile ]]
    fi

    #####
    # Fuse test (bootloaders usually cannot set fuses)
    #
    if [[ $is_bootloader -ne 1 ]]; then
      if [ -n "$EE_SIZE" ]; then
        specify="clear, set and read eesave fuse bit"
        command=(${avrdude[@]} -T '"config eesave=0; config eesave=1; config eesave"')
      else
        specify="clear, set and read wdton fuse bit"
        command=(${avrdude[@]} -T '"config wdton=0; config wdton=1; config wdton"')
      fi
      execute "${command[@]}" > $outfile
      fusebit=$(awk '{print $4}' < $outfile)
      rm $outfile
      result [[ '"$fusebit"' == 1 '&&' ! -s $logfile ]]

      if [ -n "$EE_SIZE" ]; then
        specify="set eesave fusebit to factory default: delete EEPROM on chip erase"
        command=($avrdude_bin $avrdude_conf -qq ${pgm_and_target[$p]} -cdryrun -qq -T '"config eesave"' '|'
          ${avrdude[@]} -t)
        execute "${command[@]}" > $outfile
        rm $outfile
        result [[ ! -s $logfile ]]
      fi
    fi

    #####
    # Flash test: a relatively difficult file with two code blocks and one data block with holes
    #
    specify="holes_rjmp_loops_${FLASH_SIZE}B.hex flash -U write/verify"
    command=(${avrdude[@]} -Uflash:w:test_files/holes_rjmp_loops_${FLASH_SIZE}B.hex)
    execute "${command[@]}"
    result [ $? == 0 ]
    if [ $? != 0 ]; then        # Not working? try a file without holes
      specify="flash_for_bootloaders_rjmp_loops_${FLASH_SIZE}B.hex flash -U write/verify"
      command=(${avrdude[@]} -Uflash:w:test_files/flash_for_bootloaders_rjmp_loops_${FLASH_SIZE}B.hex)
      execute "${command[@]}"
      result [ $? == 0 ]
    fi

    specify="holes_rjmp_loops_${FLASH_SIZE}B.hex flash -T write/verify"
    command=(${avrdude[@]} -T '"write flash 'test_files/holes_rjmp_loops_${FLASH_SIZE}B.hex:a'"')
    execute "${command[@]}" > $outfile
    result [[ ! -s $outfile '&&' ! -s $logfile ]]
    if [ $? != 0 ]; then        # Not working? try a file without holes
      specify="flash_for_bootloaders_rjmp_loops_${FLASH_SIZE}B.hex flash -T write/verify"
      command=(${avrdude[@]} -T '"write flash 'test_files/flash_for_bootloaders_rjmp_loops_${FLASH_SIZE}B.hex:a'"')
      execute "${command[@]}" > $outfile
      result [[ ! -s $outfile '&&' ! -s $logfile ]]
    fi

    ######
    # EEPROM test with a file containing holes
    #
    specify="holes_pack_my_box_${EE_SIZE}B.hex eeprom -U write/verify"
    command=(${avrdude[@]} -Ueeprom:w:test_files/holes_pack_my_box_${EE_SIZE}B.hex)
    execute "${command[@]}"
    result [ $? == 0 ]
    if [ $? != 0 ]; then        # Not working? try a file without holes
      specify="the_quick_brown_fox_${EE_SIZE}B.hex eeprom -U write/verify"
      command=(${avrdude[@]} -Ueeprom:w:test_files/the_quick_brown_fox_${EE_SIZE}B.hex)
      execute "${command[@]}"
      result [ $? == 0 ]
    fi

    specify="holes_the_five_boxing_wizards_${EE_SIZE}B.hex eeprom -T write/verify"
    command=(${avrdude[@]} -T '"write eeprom 'test_files/holes_the_five_boxing_wizards_${EE_SIZE}B.hex:a'"')
    execute "${command[@]}" > $outfile
    result [[ ! -s $outfile '&&' ! -s $logfile ]]
    if [ $? != 0 ]; then        # Not working? try a file without holes
      specify="lorem_ipsum_${EE_SIZE}B.srec eeprom -T write/verify"
      command=(${avrdude[@]} -T '"write eeprom 'test_files/lorem_ipsum_${EE_SIZE}B.srec:a'"')
      execute "${command[@]}" > $outfile
      result [[ ! -s $outfile '&&' ! -s $logfile ]]
    fi

    # Chip erase and verify
    if [ $check_eeprom -eq 1 ]; then
      specify="chip erase and spot check flash is erased"
      command=(${avrdude[@]} -e -Uflash:v:test_files/holes_0xff_${FLASH_SIZE}B.hex)
      execute "${command[@]}"
      result [ $? == 0 ]
      if [[ $? == 0 && $is_bootloader -eq 0 ]]; then
        specify="... and spot check eeprom is erased"
        command=(${avrdude[@]} -Uflash:v:test_files/holes_0xff_${FLASH_SIZE}B.hex)
        execute "${command[@]}"
        result [ $? == 0 ]
      fi
    fi

    # Write and verify random data to usersig if present
    if [[ -n "$USERSIG_SIZE" && $is_bootloader -ne 1 ]]; then
      tmpfile="$tmp/usersig_dump$$_${USERSIG_SIZE}B.bin"
      specify="random_data_${USERSIG_SIZE}B.bin usersig -T/-U write/read"
      command=(${avrdude[@]}
        -T '"erase usersig; write usersig test_'files/random_data_${USERSIG_SIZE}B.bin'"'
        -T flush
        -Uusersig:r:$tmpfile:r
        -T '"erase usersig"')
      execute "${command[@]}"
      touch "$tmpfile"
      result cmp -s "test_files/random_data_${USERSIG_SIZE}B.bin" "$tmpfile"
      rm -f "$tmpfile"
    fi

    if [ $FAIL == true ]; then
      echo ''
      read -rep "One or more AVRDUDE \"${pgm_and_target[$p]}\" tests failed. Do you want to retry this particular test? (y/n): " choice
      case "$choice" in
        [yY])
          p=$p-1; # Re-run the same for-loop iterator
          ;;
        *)
          # Continue with the next hardware setup in the list
          ;;
      esac
    fi

  fi #key
done #for
